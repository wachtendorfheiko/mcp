package dev.wachten.mcp.server;

import org.springframework.ai.tool.annotation.Tool;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * A Spring Service that provides file reading and writing capabilities
 * exposed as AI tools via Spring AI's @Tool annotation.
 *
 * This service operates within a configurable base directory to enhance security
 * and prevent arbitrary file system access.
 */
@Service
public class FileService {

    private static final Logger logger = LoggerFactory.getLogger(FileService.class);

    // Configurable base directory for file operations.
    // This should be set in application.properties, e.g., file.base-directory=/tmp/ai-files
    @Value("${file.base-directory:./ai-data}") // Default to ./ai-data if not specified
    private String baseDirectoryPath;

    /**
     * Constructs a safe absolute path for file operations within the configured base directory.
     * This prevents directory traversal attacks by resolving the path and ensuring it starts
     * with the canonical base directory path.
     *
     * @param filename The name of the file (can include subdirectories relative to base).
     * @return A Path object representing the safe absolute file path.
     * @throws IOException If a file system error occurs during path resolution.
     */
    private Path resolveSafePath(String filename) throws IOException {
        Path baseDir = Paths.get(baseDirectoryPath).toAbsolutePath().normalize();
        Path filePath = baseDir.resolve(filename).normalize();

        // Security check: Ensure the resolved file path is still within the base directory
        if (!filePath.startsWith(baseDir)) {
            throw new SecurityException("Attempted directory traversal: " + filename);
        }
        return filePath;
    }

    /**
     * Reads the content of a specified file.
     * This method is exposed as an AI tool.
     *
     * @param filename The name of the file to read, relative to the configured base directory.
     * @return The content of the file as a String, or an error message if the file cannot be read.
     */
    @Tool(description = "Reads the content of a text file from the application's designated file system. " +
                   "Provide the filename including its extension. " +
                   "Example: 'document.txt' or 'reports/summary.md'.")
    public String readFileContent(String filename) {
        try {
            Path filePath = resolveSafePath(filename);
            if (!Files.exists(filePath)) {
                logger.warn("File not found: {}", filePath);
                return "Error: File '" + filename + "' not found.";
            }
            if (!Files.isReadable(filePath)) {
                logger.warn("File not readable: {}", filePath);
                return "Error: File '" + filename + "' is not readable.";
            }
            String content = Files.readString(filePath, StandardCharsets.UTF_8);
            logger.info("Successfully read content from file: {}", filename);
            return content;
        } catch (SecurityException e) {
            logger.error("Security violation attempting to read file {}: {}", filename, e.getMessage());
            return "Error: Security violation - invalid file path.";
        } catch (IOException e) {
            logger.error("Error reading file {}: {}", filename, e.getMessage());
            return "Error: Could not read file '" + filename + "'. Reason: " + e.getMessage();
        }
    }

    /**
     * Writes content to a specified file, overwriting it if it already exists.
     * This method is exposed as an AI tool.
     *
     * @param filename The name of the file to write to, relative to the configured base directory.
     * @param content The string content to write into the file.
     * @return A confirmation message upon successful write, or an error message.
     */
    @Tool(description = "Writes provided content to a text file in the application's designated file system. " +
                   "If the file exists, its content will be overwritten. " +
                   "Provide the filename including its extension and the content to write. " +
                   "Example: 'new_note.txt', 'This is a new note generated by the AI.'")
    public String writeFileContent(String filename, String content) {
        try {
            Path filePath = resolveSafePath(filename);
            // Ensure parent directories exist
            Files.createDirectories(filePath.getParent());

            Files.writeString(filePath, content, StandardCharsets.UTF_8);
            logger.info("Successfully wrote content to file: {}", filename);
            return "Successfully wrote content to file '" + filename + "'.";
        } catch (SecurityException e) {
            logger.error("Security violation attempting to write file {}: {}", filename, e.getMessage());
            return "Error: Security violation - invalid file path.";
        } catch (IOException e) {
            logger.error("Error writing to file {}: {}", filename, e.getMessage());
            return "Error: Could not write to file '" + filename + "'. Reason: " + e.getMessage();
        }
    }

    /**
     * Provides a list of all files within the configured base directory.
     * This method is exposed as an AI tool.
     *
     * @return A comma-separated string of file paths relative to the base directory,
     * or an error message if the directory cannot be accessed.
     */
    @Tool(description = "Lists all files and their paths within the application's designated file system. " +
            "Returns a comma-separated list of file paths relative to the base directory.")
    public String listAllFiles() {
        try {
            Path baseDir = Paths.get(baseDirectoryPath).toAbsolutePath().normalize();
            if (!Files.exists(baseDir)) {
                logger.warn("Base directory does not exist: {}", baseDir);
                return "Error: Base directory '" + baseDirectoryPath + "' does not exist.";
            }
            if (!Files.isDirectory(baseDir)) {
                logger.warn("Base path is not a directory: {}", baseDir);
                return "Error: Base path '" + baseDirectoryPath + "' is not a directory.";
            }

            try (Stream<Path> walk = Files.walk(baseDir)) {
                List<String> filePaths = walk
                        .filter(Files::isRegularFile) // Only list regular files, not directories
                        .map(baseDir::relativize)     // Get path relative to base directory
                        .map(Path::toString)          // Convert to String
                        .collect(Collectors.toList());

                if (filePaths.isEmpty()) {
                    logger.info("No files found in directory: {}", baseDirectoryPath);
                    return "No files found in the designated directory.";
                }

                logger.info("Successfully listed files in directory: {}", baseDirectoryPath);
                return String.join(", ", filePaths);
            }
        } catch (SecurityException e) {
            logger.error("Security violation attempting to list files in {}: {}", baseDirectoryPath, e.getMessage());
            return "Error: Security violation - cannot access base directory.";
        } catch (IOException e) {
            logger.error("Error listing files in directory {}: {}", baseDirectoryPath, e.getMessage());
            return "Error: Could not list files in directory '" + baseDirectoryPath + "'. Reason: " + e.getMessage();
        }
    }
}